/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2023 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.dung.serialisibility.graph;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;

import org.tweetyproject.arg.dung.principles.Principle;
import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.reasoner.serialisable.SerialisableExtensionReasoner;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.serialisibility.NoExampleFoundException;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.commons.postulates.Postulate;
import org.tweetyproject.commons.postulates.PostulateEvaluatable;

/**
 * This class represents a generator for exemplary frameworks with serialisable extensions.
 * The objects of this class verify that the generated frameworks and their  serialisation graphs comply specified conditions.
 *
 * @see DefaultDungTheoryGenerator
 * @see org.tweetyproject.arg.dung.learning.ExampleFinder
 *
 * @author Julian Sander
 * @version TweetyProject 1.23
 *
 */
public class SerialisationGraphGenerator {

	private DefaultDungTheoryGenerator generator;
	private DungTheoryGenerationParameters parameters;
	private HashMap<Principle, AbstractExtensionReasoner> conditionsFramework = new HashMap<Principle, AbstractExtensionReasoner>();
	private int maxNumberTryGenerateFramework = 10;
	private HashMap<Postulate<Argument>, PostulateEvaluatable<Argument>> conditionsGraph = new HashMap<Postulate<Argument>, PostulateEvaluatable<Argument>>();
	//private HashMap<Postulate<Extension<Argument>>, PostulateEvaluatable<Extension<Argument>>> conditionsGraph = new HashMap<Postulate<Extension<Argument>>, PostulateEvaluatable<Extension<Argument>>>();
	//private HashMap<Postulate<TransitionState>, PostulateEvaluatable<TransitionState>> conditionsGraph = new HashMap<Postulate<TransitionState>, PostulateEvaluatable<TransitionState>>();

	/**
	 *
	 * @param numberOfArguments {@link DungTheoryGenerationParameters#numberOfArguments}
	 * @param attackProbability {@link DungTheoryGenerationParameters#attackProbability}
	 * @param avoidSelfAttacks {@link DungTheoryGenerationParameters#avoidSelfAttacks}
	 * @param maxNumberTryGenerateFramework Number how often the generator can retry to generate a framework complied to the conditions, before aborting the process.
	 */
	public SerialisationGraphGenerator(int numberOfArguments, double attackProbability, boolean avoidSelfAttacks, int maxNumberTryGenerateFramework) {
		this.parameters = new DungTheoryGenerationParameters();
		this.changeParameterNumberOfArguments(numberOfArguments);
		this.changeParameterAttackProbability(attackProbability);
		this.changeParameterSelfAttacks(avoidSelfAttacks);
		if(maxNumberTryGenerateFramework > 0) {
			this.maxNumberTryGenerateFramework = maxNumberTryGenerateFramework;
		}

		this.generator = new DefaultDungTheoryGenerator(this.parameters);
	}

	/**
	 * Adds a specified principle as a condition, which is fulfilled by all frameworks generated by this class.
	 * The specified reasoner will check if the principle is satisfied.
	 * @param condition Principle, which will be fulfilled by all frameworks generated by this class.
	 * @param reasonerToCheck Reasoner, which will be used to check whether the condition is satisfied or not.
	 */
	public void addConditionForFramework(Principle condition, AbstractExtensionReasoner reasonerToCheck) {
		this.conditionsFramework.put(condition, reasonerToCheck);
	}
	
	/**
	 * Adds a specified postulate as a condition, which is satisfied by all serialisation graphs of the serialisable extensions 
	 * wrt the specified semantics, for all generated frameworks. The parameter evaluation is used to verify the condition.
	 * @param condition condition, which is satisfied by all analyses, or rather the graph resulting from the analysis
	 * @param evaluation Used to verify if the condition is satisfied by a analysis or rather the graph resulting from the analysis
	 */
	public void addConditionForGraph(Postulate<Argument> condition, PostulateEvaluatable<Argument> evaluation) {
		this.conditionsGraph.put(condition, evaluation);
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param attackProbability {@link DungTheoryGenerationParameters#attackProbability}
	 */
	public void changeParameterAttackProbability(double attackProbability) {
		this.parameters.attackProbability = attackProbability;
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param numberOfArguments {@link DungTheoryGenerationParameters#numberOfArguments}
	 */
	public void changeParameterNumberOfArguments(int numberOfArguments) {
		this.parameters.numberOfArguments = numberOfArguments;
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param seed {@link org.tweetyproject.argumentation.util.DungTheoryGenerator#setSeed}
	 */
	public void changeParameterSeed(long seed) {
		this.generator.setSeed(seed);
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param avoidSelfAttacks {@link DungTheoryGenerationParameters#avoidSelfAttacks}
	 */
	public void changeParameterSelfAttacks(boolean avoidSelfAttacks) {
		this.parameters.avoidSelfAttacks = avoidSelfAttacks;
	}

	/**
	 * Creates an exemplary abstract argumentation framework. The framework itself, and its serialisation graphs comply to the conditions of this generator.
	 *
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, returns NULL if no framework can be generated.
	 * @param abortGraphNotComply If TRUE, an exception is thrown and the method aborted whenever an graph doesn't comply the conditions. If FALSE, returns NULL if graph doesn't satisfies conditions.
	 * @return Generated exemplary framework. 
	 * @throws NoExampleFoundException Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public DungTheory findExample(
			Semantics semanticsForSerializing, 
			boolean abortFrameworkNotComply, 
			boolean abortGraphNotComply) throws NoExampleFoundException {

		DungTheory generatedFramework = this.generateFramework(abortFrameworkNotComply);
		
		if(generatedFramework != null) {
			if(checkGraph(semanticsForSerializing, generatedFramework)) return generatedFramework;
			else if(abortGraphNotComply) throw new NoExampleFoundException();
			else return null;
		}
		return null;
	}

	

	/**
	 * Creates exemplary abstract argumentation frameworks. The frameworks themselves, and their serialisation graphs comply to the conditions of this generator.
	 *
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param numberOfExamples Number of examples generated.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Generated exemplary frameworks. 
	 * @throws NoExampleFoundException Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public DungTheory[] findExample(
			Semantics semanticsForSerializing, 
			int numberOfExamples,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws NoExampleFoundException {
		
		int numberExamplesLeft =  numberOfExamples;
		HashSet<DungTheory> results = new HashSet<DungTheory>();
		
		do {
			DungTheory analysis = this.findExample(semanticsForSerializing, abortFrameworkNotComply, abortAnalysisNotComply);
			if(analysis != null) results.add(analysis);
			numberExamplesLeft--;
		} while (numberExamplesLeft > 0);
		
		return results.toArray(new DungTheory[0]);
	}

	/**
	 * Creates exemplary argumentation frameworks and analyzes their serialisable extensions.
	 * The method generates frameworks starting with the specified number of arguments,
	 * and increasing this number by the specified increment
	 * as long as the number stays lower or equal than the specified maximum number of arguments (inclusive boundary).
	 *
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param numberOfArgumentsStart Number of Arguments of the first framework, which will be generated as an example.
	 * @param maxNumberOfArguments Maximum number of arguments of any framework generated by this method.
	 * @param numberOfExamplesPerIncrement Number of examples created with the same number of arguments.
	 * @param incrementForNumberOfArguments Increment by which the number of arguments is increased each time.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Array of analysis results, analyzing each a different randomly generated exemplary argumentation framework.
	 * @throws NoExampleFoundException Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public  DungTheory[] findExample(
			Semantics semanticsForSerializing,
			int numberOfArgumentsStart,
			int maxNumberOfArguments,
			int numberOfExamplesPerIncrement,
			int incrementForNumberOfArguments,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws NoExampleFoundException {
		
		ArrayList<DungTheory> results = new ArrayList<DungTheory>();
		
		for (int i = numberOfArgumentsStart; i <= maxNumberOfArguments; i += incrementForNumberOfArguments) {
			this.changeParameterNumberOfArguments(i);
			for (int j = 0; j < numberOfExamplesPerIncrement; j++) {
				DungTheory analysis = this.findExample(semanticsForSerializing, abortFrameworkNotComply, abortAnalysisNotComply);
				if(analysis != null) results.add(analysis);
			}
		}
		return results.toArray(new DungTheory[0]);
	}

	/**
	 * Generates argumentation frameworks and analyzes their serialisable extensions regarding the specified semantics.
	 * @param semanticsForSerializing Array of semantics, used to create the different analyses.
	 * @param numberOfExamples Number of exemplary frameworks, which will be generated.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Frameworks mapped to the associated serialisation graphs using different semantics
	 * @throws NoExampleFoundException Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public LinkedHashMap<DungTheory, SerialisationGraph[]> findExampleForDifferentSemantics(
			Semantics[] semanticsForSerializing,
			int numberOfExamples,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws NoExampleFoundException{
		
		LinkedHashMap<DungTheory, SerialisationGraph[]> results = new LinkedHashMap<DungTheory, SerialisationGraph[]>();

		for (int i = 0; i < numberOfExamples; i++) {
			DungTheory generatedFramework = this.generateFramework(abortFrameworkNotComply);
			if(generatedFramework != null)
			{
				ArrayList<SerialisationGraph> analysesForDiffSemantics = new ArrayList<SerialisationGraph>();

				for (int j = 0; j < semanticsForSerializing.length; j++) {
					if(checkGraph(semanticsForSerializing[j], generatedFramework)) 
					{
						SerialisationGraph graph = SerialisableExtensionReasoner.
								getSerialisableReasonerForSemantics(semanticsForSerializing[j]).getModelsGraph(generatedFramework);;
						if(graph != null)analysesForDiffSemantics.add(graph);
					}
				}
				
				if(analysesForDiffSemantics.isEmpty() == false)
					results.put(generatedFramework, analysesForDiffSemantics.toArray(new SerialisationGraph[0]));
			}
		}
		return results;
	}

	/**
	 * Creates exemplary argumentation frameworks and analyzes their serialisable extensions.
	 * The method generates frameworks starting with the specified number of arguments,
	 * and increasing this number by the specified increment
	 * as long as the number stays lower or equal than the specified maximum number of arguments (inclusive boundary).
	 * Creates for each framework generated one serialisation graph per specified semantics.
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param numberOfArgumentsStart Number of Arguments of the first framework, which will be generated as an example.
	 * @param maxNumberOfArguments Maximum number of arguments of any framework generated by this method.
	 * @param numberOfExamplesPerIncrement Number of examples created with the same number of arguments.
	 * @param incrementForNumberOfArguments Increment by which the number of arguments is increased each time.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Frameworks mapped to the associated serialisation graphs using different semantics
	 * @throws NoExampleFoundException Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public  LinkedHashMap<DungTheory, SerialisationGraph[]> findExampleForDifferentSemantics(
			Semantics[] semanticsForSerializing,
			int numberOfArgumentsStart,
			int maxNumberOfArguments,
			int numberOfExamplesPerIncrement,
			int incrementForNumberOfArguments,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws NoExampleFoundException
	{
		LinkedHashMap<DungTheory, SerialisationGraph[]> output = new LinkedHashMap<DungTheory, SerialisationGraph[]>();

		for (int i = numberOfArgumentsStart; i <= maxNumberOfArguments; i += incrementForNumberOfArguments) {
			this.changeParameterNumberOfArguments(i);
			output.putAll(this.findExampleForDifferentSemantics(semanticsForSerializing, numberOfExamplesPerIncrement, abortFrameworkNotComply, abortAnalysisNotComply));
		}

		return output;
	}

	/**
	 * Generates a framework, which complies to the specified conditions
	 * @throws NoExampleFoundException Throws an exception, if the generated frameworks couldn't satisfy the condition within the specified number of allowed attempts
	 */
	private DungTheory generateFramework(boolean abortFrameworkNotComply) throws NoExampleFoundException {
		DungTheory generatedFramework;

		boolean mustRepeat = false;
		int numTryLeft = this.maxNumberTryGenerateFramework;
		do {
			if(numTryLeft == 0) {
				if(abortFrameworkNotComply)throw new NoExampleFoundException();
				else return null;
			}
			generatedFramework = this.generator.next();


			for (Principle condition : this.conditionsFramework.keySet()) {
				boolean conditionSatisfied = condition.isSatisfied(generatedFramework, this.conditionsFramework.get(condition));
				if(!conditionSatisfied) {
					mustRepeat = true;
				}
			}
			numTryLeft--;
		} while (mustRepeat);
		return generatedFramework;
	}
	
	/**
	 * 
	 * @param semanticsForSerializing Semantics used to serialize the extensions
	 * @param framework Argumentation framework, in which the extension will be searched
	 * @return TRUE iff derived graph of the framework complies the conditions of the generator.
	 * @throws NoExampleFoundException Throws the exception if the derived analysis, couldn't satisfy the condition
	 */
	private boolean checkGraph(
			Semantics semanticsForSerializing,
			DungTheory framework){
		
		//SerialisationGraph graph = SerialisableExtensionReasonerWithAnalysis.
		//		getSerialisableReasonerForSemantics(semanticsForSerializing).getModelsGraph(framework);
		
		boolean analysisAccepted = true;
		//for (Postulate<Argument> condition : this.conditionsGraph.keySet()) {
			//boolean conditionIsSatisfied = condition.isSatisfied(output.getGraphResulting().getNodes(), this.conditionsAnalysis.get(condition));
			//if(conditionIsSatisfied == false) analysisAccepted = false;
		//}
		/*
		 * if(analysisAccepted == false) { if(abortAnalysisNotComply)throw new
		 * NoExampleFoundException(); else return null; }
		 */
		
		return analysisAccepted;
	}
}
